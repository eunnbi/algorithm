# Depth First Search

## DFS μ •μ

λ‹¤μ°¨μ› λ°°μ—΄μ—μ„ κ° μΉΈμ„ λ°©λ¬Έν•  λ• κΉμ΄λ¥Ό μ°μ„ μΌλ΅ λ°©λ¬Έν•λ” μ•κ³ λ¦¬μ¦

## κµ¬ν„ λ°©λ²•

1. μ‹μ‘ν•λ” μΉΈμ„ μ¤νƒμ— λ„£κ³  λ°©λ¬Έν–λ‹¤λ” ν‘μ‹λ¥Ό λ‚¨κΉ€
2. μ¤νƒμ—μ„ μ›μ†λ¥Ό κΊΌλ‚΄μ–΄ κ·Έ μΉΈκ³Ό μƒν•μΆμ° μΈμ ‘ν• μΉΈμ— λ€ν•΄ 3λ²μ„ μ§„ν–‰
3. ν•΄λ‹Ή μΉΈμ„ μ΄μ „μ— λ°©λ¬Έν–λ‹¤λ©΄ pass, μ²μμΌλ΅ λ°©λ¬Έν–λ‹¤λ©΄ λ°©λ¬Έν–λ‹¤λ” ν‘μ‹λ¥Ό λ‚¨κΈ°κ³  ν•΄λ‹Ή μΉΈμ„ μ¤νƒμ— μ‚½μ…
4. μ¤νƒμ΄ λΉ λ•κΉμ§€ 2λ² λ°λ³µ

```python
from collections import deque

n, m = map(int, input.split())

dx = [-1, 1, 0, 0]
dy = [0, 0, 1, -1]

visited = [[-1] * m for _ in range(n)]

def dfs(matrix):
	stack = [[0, 0]]
	visited[0][0] = 1
	
	while queue:
		x, y = stack.pop()
		for i in range(4):
			nx, ny = x + dx[i], y + dy[i]
			if (nx < 0 or nx >= n or ny < 0 or ny >= m):
				continue
			if (visited[nx][ny] != -1 or matrix[nx][ny] != 1):
				continue
			stack.append([nx, ny])
			visited[nx][ny] = visited[x][y] + 1
```

## μ‹κ°„λ³µμ΅λ„

λ¨λ“  μΉΈμ΄ μ¤νƒμ— 1λ²μ”© λ“¤μ–΄κ°€λ―€λ΅ μ‹κ°„ λ³µμ΅λ„λ” μΉΈμ΄ NμΌ λ• O(N)

## BFS vs DFS

π’΅ λ°©λ¬Έ μμ„μ— μμ–΄μ„ ν° μ°¨μ΄κ°€ μμ.

- BFS: **μμ‹ κ³Ό κ±°λ¦¬κ°€ κ°€κΉμ΄ μΉΈλ¶€ν„°** μμ„λ€λ΅ λ°©λ¬Έν•λ‹¤.
- DFS: ν• λ°©ν–¥μΌλ΅ λ§‰ν λ•κΉμ§€ μ­‰ λ°©λ¬Έν•λ‹¤. κ·Έλμ„ κ° μΉΈλ§λ‹¤ μ‹μ‘μ μΌλ΅λ¶€ν„° κ±°λ¦¬λ¥Ό κµ¬ν•  μ μ—†λ‹¤.
# Basic

## 자주 사용되는 해결전략

### 단순 시뮬레이션

- `What` 기본적으로 사용되며, 문제 해결 실마리를 찾는 전략
- `When` 주로 제약 조건이 작은 경우에 사용됨.
- `How` 규칙성 파악, 중복된 부분 문제 발견

### 거꾸로 생각하기

- `What` 정답의 반대 상황을 간단하게 구하고, 이를 통해 해결하는 전략
- `When` 주로 반대 상황을 구하기 쉽고, 해당 값을 바탕으로 정답을 구하기 용이할 때 자주 사용됨.
- 예시: https://www.acmicpc.net/problem/2631
  - 옮기는 아이들의 수 최소화에 초점을 맞추기 보다는 움직이지 않는 아이들의 수를 최대화하는 관점에서 문제를 해결하는 것이 쉽다.

### 이전에 풀어본 문제와 비슷한가?

- `What` 이전에 풀어본 문제와 유사한 지를 바탕으로 풀이를 설계하는 전략
- 상당한 양의 연습이 필요한 전략 → 소위 Well-known 유형들에 대한 문제 풀이를 우선적으로 공부한다.


## 시간복잡도

| N의 크기      | 허용 시간복잡도 |
| ------------- | --------------- |
| N ≤ 11        | O(N!)           |
| N ≤ 25        | O(2^N)          |
| N ≤ 100       | O(N^4)          |
| N ≤ 500       | O(N^3)          |
| N ≤ 3000      | O(N^2logN)      |
| N ≤ 5000      | O(N^2)          |
| N ≤ 1,000,000 | O(NlogN)        |
| N≤ 10,000,000 | O(N)            |
| 그 이상       | O(logN), O(1)   |

🚀 **Remember that `10,000 * 10,000` takes about one second.**


## 공간복잡도

- 512MB = 1.2억 개의 int 형
- 사이즈가 큰 변수는 전역 변수로 선언

## 데이터 타입

### char, short, int

|          | char형        | short형      | int형           |
| -------- | ------------- | ------------ | --------------- |
| byte     | 1byte (=8bit) | 2byte        | 4byte           |
| unsigned | 0 ~ 255       | 0 ~ 65,535   | 0~약 42억       |
| signed   | -128 ~ 127    | -32768~32767 | 약 -21억 ~ 21억 |

🚀 **`Integer Overflow` 주의!** Integer overflow가 발생하면 `int`형 대신 `long long` 형으로 선언

### float, double

- 실수의 저장 및 연산 과정에서 오차가 발생할 수 있다.
  - 가수부의 bit 수 제한 → 유효 자릿수 존재
- double에 long long 범위의 정수를 함부로 담으면 안된다.
  - 가수부의 bit 수 제한 때문이다.
- 실수를 비교할 때 등호를 사용해선 안된다. 등호 대신 부등호를 이용한다.
  - abs(a-b) < 1e-12 → a와 b는 동일한 값으로 판단


## 함수 호출

1. `call by value`
   - argument의 상수값을 복사하여 전달
   - 원본 데이터 변경 불가능
2. `call by reference`
   - argument의 시작주소 전달
   - 함수 내부에서 원본 수정 가능


## STL과 함수 호출

- STL를 함수 인자에 넣으면 복사되어 전달된다. => `call by value`
- 복사본을 만드는데 비용이 발생한다.

  ```cpp
  // O(N)
  bool cmp1(vector<int> v1, vector<int> v2, int idx){
      return v1[idx] > v2[idx];
  }

  // O(1)
  bool cmp1(vector<int>& v1, vector<int>& v2, int idx){
      return v1[idx] > v2[idx];
  }
  ```

<br/>

> 💡 코딩테스트의 목표는 남이 알아볼 수 있는 클린코드를 작성하는 것이 아니다. 어떻게든 제한된 시간 안에 정답을 받아야 한다!
